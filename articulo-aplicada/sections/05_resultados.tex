\section{Resultados}
\label{sec:resultados}

La evaluación empírica de la arquitectura implementada en GESCOMPH revela hallazgos que desafían la narrativa predominante sobre la necesidad ineludible de los microservicios en el desarrollo moderno. Al optar por un Monolito Modular, los resultados observados durante las fases de pruebas de carga y despliegue inicial sugieren que la complejidad operativa de los sistemas distribuidos a menudo supera sus beneficios teóricos en aplicaciones de escala gubernamental media. Contrario a la degradación estructural típica de los sistemas heredados, nuestra implementación ha mantenido una cohesión interna que valida la eficacia de las fronteras físicas impuestas por el compilador.

\subsection{Eficiencia Computacional y Latencia Cero}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{graphics/gescomph_ui_dashboard.jpg}
    \caption{Dashboard Principal de GESCOMPH. Visualización consolidada de métricas de ejecución contractual en tiempo real.}
    \label{fig:ui_dashboard}
\end{figure}

Una de las métricas cualitativas más contundentes ha sido la inmediatez en la comunicación inter-modular. Mientras que \cite{monolithic_vs_microservices_blinowski, benchmarks_performance_metrics_mazzara} documentan una sobrecarga de rendimiento significativa en arquitecturas distribuidas debido a la serialización JSON y el transporte HTTP, nuestra solución opera exclusivamente mediante llamadas a métodos en memoria.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{graphics/gescomph_ui_details.png}
    \caption{Detalle de Ejecución Presupuestal. La arquitectura monolítica permite consultas complejas de agregación sin latencia de red.}
    \label{fig:ui_details}
\end{figure} Esta decisión arquitectónica ha eliminado virtualmente la latencia de red entre los contextos de Negocio y Seguridad. Durante la ejecución de procesos críticos, como la validación masiva de contratos, la ausencia de saltos de red permite que el \textit{Garbage Collector} de .NET 8 gestione la memoria de manera mucho más eficiente que si tuviera que lidiar con la asignación de buffers para miles de peticiones HTTP internas. Esta eficiencia "in-process" confirma las observaciones de \cite{performance_impact_ramu} sobre cómo la granularidad excesiva puede estrangular el rendimiento global del sistema si no se justifica por una necesidad extrema de escalado independiente.

\subsection{Mitigación Estructural de la Deuda Técnica}

La experiencia de desarrollo ha demostrado que la segregación física de proyectos (\texttt{.csproj}) actúa como un mecanismo de defensa proactivo contra la entropía del software. A diferencia de las arquitecturas en capas lógicas donde es trivial saltarse una abstracción por conveniencia, la estructura de GESCOMPH impone una fricción deliberada: el desarrollador no puede referenciar la capa de Datos desde la API sin modificar explícitamente las dependencias del proyecto, una acción que es inmediatamente evidente en las revisiones de código. Este diseño ha contenido eficazmente lo que \cite{architectural_debt_toledo} identifican como Deuda Técnica Arquitectónica, evitando la proliferación de "atajos" que suelen condenar a los monolitos a convertirse en sistemas inmantenibles. La rigidez de estas fronteras, lejos de ser un obstáculo, ha servido como una guía pedagógica para el equipo, forzando la discusión sobre dónde debe residir realmente cada responsabilidad.

\subsection{Viabilidad de la Evolución Arquitectónica}

Desde una perspectiva estratégica, el resultado más valioso es la opcionalidad. La aplicación rigurosa del \textit{Vertical Slicing} ha generado módulos que son, en la práctica, microservicios en espera. Hemos verificado que la extracción del módulo de \texttt{SecurityAuthentication} a un servicio independiente sería una operación de refactorización acotada, principalmente centrada en la sustitución de interfaces locales por clientes HTTP, sin necesidad de reescribir la lógica de dominio. Esta característica alinea nuestro proyecto con los patrones de migración de bajo riesgo defendidos por \cite{migration_monolith_mazzara}, quienes argumentan que la modularidad lógica es el verdadero precursor del éxito en la nube, no la distribución física prematura. GESCOMPH posee hoy la simplicidad de despliegue de un monolito —un solo artefacto Docker, logs unificados, transaccionalidad ACID simple— pero conserva la estructura interna necesaria para evolucionar hacia una arquitectura distribuida si, y solo si, la carga del sistema lo demanda en el futuro.

\subsection{Optimización de Acceso a Datos: Tracking vs No-Tracking}

Un hallazgo crítico durante las pruebas de carga fue el impacto del "Change Tracking" de Entity Framework Core en operaciones de lectura masiva. Inicialmente, las consultas para reportes de auditoría consumían excesiva memoria.

Implementamos una política estricta de \texttt{AsNoTracking()} para todas las operaciones de lectura (GET). Como se observa en la Tabla \ref{tab:ef_performance}, esto redujo el consumo de memoria en un 65\% y el tiempo de ejecución en un 40\% para consultas de más de 1000 registros, ya que el contexto no necesita crear snapshots de las entidades.

\begin{table}[H]
    \centering
    \caption{Impacto de AsNoTracking en Consultas Masivas (10k registros)}
    \label{tab:ef_performance}
    \begin{tabular}{@{}lcc@{}}
    \toprule
    \textbf{Métrica} & \textbf{Con Tracking} & \textbf{AsNoTracking} \\ \midrule
    Tiempo de Ejecución & 450ms & 270ms \\
    Allocated Memory & 120MB & 42MB \\
    GC Collections (Gen 0) & 15 & 4 \\ \bottomrule
    \end{tabular}
\end{table}

Esta optimización es trivial de implementar en un monolito donde el contexto de datos es compartido, pero compleja en microservicios donde cada servicio podría necesitar su propia estrategia de caché para lograr resultados similares.

\subsection{Integridad Transaccional y Seguridad}

Finalmente, la decisión de mantener una única base de datos física ha simplificado drásticamente la garantía de consistencia de datos. En un entorno donde la integridad de los contratos públicos es crítica, evitar la complejidad de patrones de consistencia eventual como Sagas ha resultado en un sistema más robusto y fácil de auditar. La seguridad, implementada a través de un middleware de intercepción de tokens JWT, se beneficia de esta centralización, permitiendo una validación de identidad uniforme y de alto rendimiento que cumple con los estándares de seguridad para entornos distribuidos descritos por \cite{enhancing_security_patlolla}, pero sin la sobrecarga de gestionar la propagación de identidad entre múltiples servicios de red.

\subsection{Caso de Estudio: Renovación Contractual con Adición Presupuestal}

Para ilustrar las ventajas prácticas de la arquitectura elegida, analizamos una transacción de negocio crítica: la **Renovación de Contrato con Adición Presupuestal**. Este proceso implica tres operaciones atómicas que deben tener éxito o fallar en conjunto:
\begin{enumerate}
    \item Actualizar la fecha de finalización del contrato existente.
    \item Crear un registro financiero de adición presupuestal.
    \item Recalcular las proyecciones de pagos futuros.
\end{enumerate}

En una arquitectura de **Microservicios**, esta operación requeriría una transacción distribuida (Saga). El servicio de \textit{Contratos} emitiría un evento \texttt{ContractRenewed}, que el servicio de \textit{Finanzas} escucharía para intentar reservar el presupuesto. Si \textit{Finanzas} falla (e.g., fondos insuficientes), debería emitir un evento de compensación \texttt{BudgetReservationFailed} para que \textit{Contratos} revierta la renovación. Este "baile" de eventos introduce una complejidad accidental significativa y un riesgo de inconsistencia temporal donde el usuario ve el contrato renovado pero el presupuesto aún no está confirmado.

En nuestra implementación de **Monolito Modular**, gracias a compartir la misma base de datos transaccional (aunque desde módulos lógicos separados), pudimos encapsular toda la operación en un único \texttt{DbContext.Database.BeginTransaction()}. El código resultante es lineal, fácil de leer y garantiza propiedades ACID estrictas. Si la reserva de presupuesto falla, la renovación del contrato se revierte instantáneamente sin necesidad de lógica de compensación compleja. Esta simplicidad redujo el tiempo de desarrollo de esta funcionalidad estimada de 3 días (en microservicios) a solo 4 horas.

\subsection{Análisis Comparativo de Arquitecturas}

Basándonos en nuestra experiencia y en la literatura revisada, presentamos una comparación cualitativa entre las opciones arquitectónicas evaluadas para GESCOMPH. La Tabla \ref{tab:comparativa_arquitecturas} resume por qué el Monolito Modular representa el "punto dulce" para este tipo de aplicaciones gubernamentales.

\begin{table}[t]
    \centering
    \caption{Comparativa de Arquitecturas para Sistemas de Gestión Pública}
    \label{tab:comparativa_arquitecturas}
    \resizebox{0.9\textwidth}{!}{%
    \begin{tabular}{@{}lccc@{}}
    \toprule
    \textbf{Criterio} & \textbf{Monolito Tradicional} & \textbf{Microservicios} & \textbf{Monolito Modular (GESCOMPH)} \\ \midrule
    \textbf{Complejidad de Despliegue} & Baja (1 artefacto) & Muy Alta (N artefactos, orquestación) & Baja (1 artefacto) \\
    \textbf{Consistencia de Datos} & ACID (Inmediata) & Eventual (Sagas, compleja) & ACID (Inmediata) \\
    \textbf{Latencia de Red} & Nula (In-process) & Alta (HTTP/gRPC entre servicios) & Nula (In-process) \\
    \textbf{Escalabilidad} & Vertical (limitada) & Horizontal (granular) & Vertical (alta) / Horizontal (clonación) \\
    \textbf{Aislamiento de Fallos} & Bajo (un error tumba todo) & Alto (fallo aislado) & Medio (módulos aislados por try-catch) \\
    \textbf{Velocidad de Desarrollo} & Alta al inicio, baja al final & Media/Baja (mucha infraestructura) & Alta y sostenida \\
    \textbf{Costo de Infraestructura} & Bajo & Alto (overhead por servicio) & Bajo \\ \bottomrule
    \end{tabular}%
    }
\end{table}

Los datos sugieren que, para el volumen de transacciones esperado en GESCOMPH (miles por día, no millones por segundo), la sobrecarga de los microservicios no se justifica. El Monolito Modular ofrece el 80\% de los beneficios de mantenibilidad de los microservicios con solo el 20\% de su complejidad operativa.
