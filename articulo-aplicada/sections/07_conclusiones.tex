\section{Conclusiones}
\label{sec:conclusiones}

Existe una inercia en la industria del software que empuja a los equipos a adoptar microservicios casi por defecto, equiparando distribución con modernidad. Nuestra experiencia construyendo GESCOMPH desafía esa noción. Al final del día, lo que hemos comprobado es que la complejidad de red es un precio demasiado alto para sistemas que, como este, requieren ante todo integridad transaccional y simplicidad operativa. No hemos construido un "monolito" en el sentido peyorativo de código espagueti; hemos construido una unidad de despliegue única que, internamente, respeta fronteras tan estrictas como si fueran servicios físicos.

La lección crítica aquí no es sobre tecnología, sino sobre disciplina. Usar .NET 8 y Docker no garantiza nada si la arquitectura subyacente permite atajos. Lo que realmente ha marcado la diferencia en este proyecto ha sido la imposición de barreras físicas —los archivos \texttt{.csproj} separados— que obligaron al equipo a pensar en contratos e interfaces antes de escribir una sola línea de lógica. Esa fricción, que a veces resultaba molesta durante el desarrollo temprano, es la que ahora nos permite afirmar que el sistema es mantenible.

Mirando hacia adelante, GESCOMPH no necesita ser reescrito para escalar. Gracias al \textit{Vertical Slicing}, ya tenemos las "costuras" por donde cortar el sistema si algún día el tráfico lo exige. Pero hasta que ese día llegue, nos quedamos con la eficiencia de la memoria compartida y la simplicidad de una sola base de datos. La verdadera innovación en el sector público no está en usar la arquitectura de Netflix, sino en entregar software que funcione, que sea seguro y que no requiera un ejército de ingenieros para mantenerlo operativo. Ese es el pragmatismo que defendemos, alineado con la visión de gobernanza inteligente de \cite{microservices_strategic_yustiana}.
