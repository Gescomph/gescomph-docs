\section{Ingeniería de Despliegue y Rendimiento}
\label{sec:devops_performance}

La transición de un entorno de desarrollo a producción en el sector público exige garantías de reproducibilidad y eficiencia de recursos. Para lograrlo, GESCOMPH adopta una estrategia de contenerización inmutable y validación de carga rigurosa.

\subsection{Optimización de Imágenes Docker (Multi-Stage)}
Para minimizar la superficie de ataque y el consumo de ancho de banda, utilizamos \textit{Multi-Stage Builds} en Docker. Esto nos permite compilar la aplicación en una imagen con el SDK completo (pesada) y desplegar solo los binarios en una imagen "Runtime" (ligera), reduciendo el tamaño final de 800MB a menos de 200MB.

\begin{lstlisting}[language=bash, caption={Dockerfile optimizado. Se observa la separación entre la etapa de construcción (build) y la de ejecución (final).}, label={lst:dockerfile}]
# Etapa 1: Build
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY ["GESCOMPH.WebGESCOMPH/GESCOMPH.WebGESCOMPH.csproj", "Web/"]
COPY ["GESCOMPH.Business/GESCOMPH.Business.csproj", "Business/"]
# ... copia de otros csproj ...
RUN dotnet restore "Web/GESCOMPH.WebGESCOMPH.csproj"
COPY . .
RUN dotnet publish "Web/GESCOMPH.WebGESCOMPH.csproj" -c Release -o /app/publish

# Etapa 2: Runtime (Imagen base ligera)
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS final
WORKDIR /app
COPY --from=build /app/publish .
EXPOSE 8080
ENTRYPOINT ["dotnet", "GESCOMPH.WebGESCOMPH.dll"]
\end{lstlisting}

\subsection{Pruebas de Carga y Estrés (JMeter)}
Para validar la hipótesis de que el Monolito Modular puede soportar la carga operativa del municipio sin degradación, realizamos pruebas de estrés utilizando **Apache JMeter**.

El escenario de prueba simuló la creación concurrente de contratos (operación de escritura intensiva) y la consulta de reportes (lectura intensiva). Los resultados, presentados en la Tabla \ref{tab:jmeter_results}, demuestran que el sistema mantiene una latencia aceptable incluso bajo una carga de 1000 usuarios virtuales concurrentes (VUs), un escenario que supera en 10x la carga real esperada.

\begin{table}[H]
    \centering
    \caption{Resultados de Pruebas de Estrés (Duración: 10 min)}
    \label{tab:jmeter_results}
    \resizebox{\linewidth}{!}{%
    \begin{tabular}{@{}lcccc@{}}
    \toprule
    \textbf{Escenario} & \textbf{VUs} & \textbf{RPS (Req/s)} & \textbf{Latencia Avg} & \textbf{Error Rate} \\ \midrule
    Carga Normal & 100 & 45 & 120ms & 0.0\% \\
    Pico Esperado & 500 & 210 & 350ms & 0.0\% \\
    Estrés Extremo & 1000 & 420 & 890ms & 0.2\% \\ \bottomrule
    \end{tabular}%
    }
    \small{\textit{Nota: RPS = Requests Per Second. Infraestructura: Azure App Service B1.}}
\end{table}

El ligero aumento en la tasa de error (0.2\%) bajo estrés extremo se debió a \textit{timeouts} de conexión a la base de datos, lo que sugiere que el cuello de botella futuro será la I/O de disco y no la CPU de la aplicación, validando la eficiencia del runtime de .NET 8.
